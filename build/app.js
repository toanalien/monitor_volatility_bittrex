// Generated by LiveScript 1.5.0
(function(){
  var async, lodash, request, express, ms, app, server_port, time_cache, limitOrderBook, CACHE, WALL_DATA, LIST_PAIR, objToString, textError, raschet, percentageBetweenNumbers, orderBook, orderBookPair, currencyPairList, loadDataPair, reg, htmlData, loading, main, request_n;
  async = require('async');
  lodash = require('lodash');
  request = require('request');
  express = require('express');
  ms = require('ms');
  app = express();
  server_port = process.env.PORT || 3000;
  time_cache = process.env.TIME_CACHE || 10;
  limitOrderBook = process.env.LIMIT_ORDER_BOOK || 100;
  CACHE = {
    date: 0,
    data: []
  };
  WALL_DATA = {};
  LIST_PAIR = [];
  objToString = function(obj){
    var str;
    str = '';
    Object.keys(obj).forEach(function(p){
      if (obj.hasOwnProperty(p)) {
        return str += p + " :: " + obj[p] + "\n";
      }
    });
    return str;
  };
  textError = function(err){
    if (lodash.isObject(err)) {
      if (err.hasOwnProperty('error')) {
        return err.error;
      } else if (err.hasOwnProperty('message')) {
        return err.message;
      } else {
        return objToString(err);
      }
    } else {
      return err;
    }
  };
  raschet = function(a, b){
    return Math.abs((b - a) / a * 100);
  };
  percentageBetweenNumbers = function(a, b){
    return +(100 * (a - b) / b).toFixed(1);
  };
  orderBook = function(list_pair, cbk){
    var x$;
    x$ = [];
    async.each(list_pair, function(pair){
      return x$.push(function(cbk){
        return orderBookPair(pair, cbk);
      });
    });
    async.parallel(x$, cbk);
    return x$;
  };
  orderBookPair = function(pair, cbk){
    var avg_percent;
    avg_percent = 300;
    return reg("getorderbook?market=" + pair + "&type=both&depth=" + limitOrderBook, function(err, body){
      var obj, e, objBuy, objSell, wallData, bid_sum, bid_avg, bid_index, ask_sum, ask_avg, ask_index;
      if (err != null) {
        return cbk(err);
      }
      try {
        obj = JSON.parse(body);
      } catch (e$) {
        e = e$;
        return cbk(e);
      }
      if (obj.result.buy == null || obj.result.sell == null) {
        WALL_DATA[pair] = {
          bid: 0,
          ask: 0
        };
        return cbk(null);
      }
      if (!obj.result.buy.length || !obj.result.sell.length) {
        WALL_DATA[pair] = {
          bid: 0,
          ask: 0
        };
        return cbk(null);
      }
      objBuy = obj.result.buy.splice(0, limitOrderBook);
      objSell = obj.result.sell.splice(0, limitOrderBook);
      wallData = {};
      bid_sum = lodash.sumBy(objBuy, function(v){
        return v.Quantity;
      });
      bid_avg = bid_sum / limitOrderBook;
      bid_index = lodash.findIndex(objBuy, function(v){
        return percentageBetweenNumbers(v.Quantity, bid_avg) > avg_percent;
      });
      ask_sum = lodash.sumBy(objSell, function(v){
        return v.Quantity;
      });
      ask_avg = ask_sum / limitOrderBook;
      ask_index = lodash.findIndex(objSell, function(v){
        return percentageBetweenNumbers(v.Quantity, ask_avg) > avg_percent;
      });
      WALL_DATA[pair] = {
        bid: objBuy[bid_index].Rate,
        ask: objSell[ask_index].Rate
      };
      return cbk(null);
    });
  };
  currencyPairList = function(cbk){
    var listPair;
    listPair = [];
    return reg("getmarkets", function(err, body){
      var obj, e;
      if (err != null) {
        return cbk(err);
      }
      try {
        obj = JSON.parse(body);
      } catch (e$) {
        e = e$;
        return cbk(e);
      }
      Object.keys(obj.result).forEach(function(pair){
        listPair.push(obj.result[pair].MarketName);
      });
      LIST_PAIR = listPair;
      return cbk(null, listPair);
    });
  };
  loadDataPair = function(list_pair, cbk){
    return reg("getmarketsummaries", function(err, body){
      var obj, e, pair_max_pr;
      if (err != null) {
        return cbk(err);
      }
      try {
        obj = JSON.parse(body);
      } catch (e$) {
        e = e$;
        return cbk(e);
      }
      pair_max_pr = {};
      Object.keys(obj.result).forEach(function(key){
        pair_max_pr[obj.result[key].MarketName] = {
          max_pr: raschet(obj.result[key].High, obj.result[key].Low).toFixed(2),
          buy: obj.result[key].Bid,
          sell: obj.result[key].Ask,
          volume: +obj.result[key].Volume.toFixed(2),
          quoteVolume: +obj.result[key].BaseVolume.toFixed(2)
        };
      });
      return cbk(null, {
        pair_max_pr: pair_max_pr
      });
    });
  };
  reg = function(method, cbk){
    return request({
      timeout: 20000,
      url: "https://bittrex.com/api/v1.1/public/" + method
    }, function(err, resp, body){
      if (err != null) {
        return cbk(err);
      }
      return cbk(null, body);
    });
  };
  htmlData = function(data, cbk){
    var css, endTime, html;
    css = {
      div: "margin-bottom: 10px; border-bottom: 1px solid black; width: 1200px;",
      span: "width: 150px; display: inline-block;",
      donate: "margin-left: 1000px; margin-top: 24px;"
    };
    endTime = Math.ceil((CACHE.date + ms(time_cache + "m") - lodash.now()) / (1000 * 60));
    html = [
      "<html><head><title>Анализ волатильности торговых пар биржи Bittrex</title></head><body>", "<h2>Анализ волатильности торговых пар биржи Bittrex</h2>", "<h3>Время: " + new Date(CACHE.date).toLocaleTimeString('en-US', {
        timeZone: 'Europe/Moscow',
        hour12: false
      }) + " &nbsp;&nbsp;&nbsp; Обновление кэша через: " + endTime + " мин. </h3>", "<div style='" + css.div + "'><span style='" + css.span + "'>Пара</span><span style='" + css.span + "'>% волотильности</span><span style='" + css.span + "'>Ask</span><span style='" + css.span + "'>Bid</span><span style='" + css.span + "'>Стенка на Ask</span><span style='" + css.span + "'>Стенка на Bid</span><span style='" + css.span + "'>Volume</span><span style='" + css.span + "'>Volume Fork</span></div>"
    ];
    data.forEach(function(v){
      html.push("<div><span style='" + css.span + "'>" + v[0].replace('-', '/') + "</span><span style='" + css.span + "'>" + v[1] + "</span><span style='" + css.span + "'>" + v[2] + "</span><span style='" + css.span + "'>" + v[3] + "</span><span style='" + css.span + "'>" + v[4] + "</span><span style='" + css.span + "'>" + v[5] + "</span><span style='" + css.span + "'>" + v[6] + "</span><span style='" + css.span + "'>" + v[7] + "</span></div>");
    });
    html.push("<div style='" + css.donate + "'>BTC: 1GGbq5xkk9YUUy4QTqsUhNnc9T1n3sQ9Fo</div>");
    html.push("</body></html>");
    return cbk(html.join(" "));
  };
  loading = false;
  main = function(res){
    if (lodash.now() - CACHE.date > ms(time_cache + "m")) {
      loading = true;
      console.log("Started updating the cache ...");
      return async.waterfall([
        function(cbk){
          return currencyPairList(cbk);
        }, function(data, cbk){
          return orderBook(data, cbk);
        }
      ], function(err){
        var text;
        if (err != null) {
          loading = false;
          text = "Error!";
          res.send(text);
          console.error("\nError: ", textError(err));
        } else {
          loadDataPair(LIST_PAIR, function(err, data){
            var text, sortable, sorted;
            if (err != null) {
              loading = false;
              text = "Error!";
              res.send(text);
              console.error("\nError: ", textError(err));
            } else {
              sortable = [];
              Object.keys(data.pair_max_pr).forEach(function(key){
                sortable.push([key, data.pair_max_pr[key].max_pr, data.pair_max_pr[key].buy, data.pair_max_pr[key].sell, WALL_DATA[key].ask, WALL_DATA[key].bid, data.pair_max_pr[key].quoteVolume, data.pair_max_pr[key].volume]);
              });
              sorted = sortable.sort(function(a, b){
                return b[1] - a[1];
              });
              console.log("Cache updated successfully");
              CACHE = {
                date: lodash.now(),
                data: sorted
              };
              htmlData(CACHE.data, function(html){
                loading = false;
                res.type("text/html");
                res.status(200);
                res.send(html);
              });
            }
          });
        }
      });
    } else {
      return htmlData(CACHE.data, function(html){
        res.type("text/html");
        res.status(200);
        res.send(html);
      });
    }
  };
  request_n = 1;
  app.get('/', function(req, res){
    if (loading) {
      return res.send("Упс... Данные еще загружаются. Перезапросите страницу через 10 секунд.");
    } else {
      console.log("request №: " + (request_n++));
      return main(res);
    }
  });
  app.listen(server_port, function(){
    return console.log("App listening on port " + server_port + "!");
  });
}).call(this);
